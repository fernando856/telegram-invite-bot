#!/bin/bash

# Script para Restaurar Sistema de Competi√ß√µes
# Implementa sistema completo de competi√ß√µes como funcionava antes
# Autor: Manus AI

echo "üèÜ RESTAURAR SISTEMA DE COMPETI√á√ïES"
echo "==================================="
echo "üéØ Implementando sistema completo de competi√ß√µes"
echo "‚è±Ô∏è  $(date)"
echo "==================================="

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Verificar se estamos no diret√≥rio correto
if [ ! -f "main.py" ]; then
    log_error "Execute este script no diret√≥rio do projeto (/root/telegram-invite-bot)"
    exit 1
fi

echo "üõë PASSO 1: Parar servi√ßo"
echo "========================"

log_info "Parando servi√ßo telegram-bot..."
systemctl stop telegram-bot 2>/dev/null || true
log_success "Servi√ßo parado"

echo ""
echo "üèÜ PASSO 2: Criar competition_commands.py completo"
echo "=================================================="

COMPETITION_FILE="src/bot/handlers/competition_commands.py"

log_info "Fazendo backup do arquivo atual..."
cp "$COMPETITION_FILE" "${COMPETITION_FILE}.before_restore.backup" 2>/dev/null || true

log_info "Criando sistema completo de competi√ß√µes..."

cat > "$COMPETITION_FILE" << 'EOF'
"""
Competition Commands - Sistema Completo
Gerenciamento completo de competi√ß√µes de convites
"""

import logging
from datetime import datetime, timedelta
import sqlite3
from telegram import Update
from telegram.ext import ContextTypes

logger = logging.getLogger(__name__)

class CompetitionCommands:
    """
    Sistema completo de comandos de competi√ß√£o
    """
    
    def __init__(self):
        self.db_path = "bot_database.db"
        self.init_database()
    
    def get_connection(self):
        """
        Retorna conex√£o com banco
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        except Exception as e:
            logger.error(f"Erro ao conectar: {e}")
            return None
    
    def init_database(self):
        """
        Inicializa tabelas necess√°rias
        """
        try:
            conn = self.get_connection()
            if not conn:
                return False
            
            cursor = conn.cursor()
            
            # Tabela de competi√ß√µes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS competitions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    description TEXT,
                    start_date DATETIME NOT NULL,
                    end_date DATETIME NOT NULL,
                    is_active INTEGER DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Tabela de participantes
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS competition_participants (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    competition_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    invites_count INTEGER DEFAULT 0,
                    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (competition_id) REFERENCES competitions (id),
                    UNIQUE(competition_id, user_id)
                )
            """)
            
            # Tabela de convites (se n√£o existir)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS invite_links (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    invite_link TEXT NOT NULL,
                    uses INTEGER DEFAULT 0,
                    competition_id INTEGER,
                    is_active INTEGER DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (competition_id) REFERENCES competitions (id)
                )
            """)
            
            # Tabela de usu√°rios (se n√£o existir)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER UNIQUE NOT NULL,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    is_active INTEGER DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            conn.commit()
            conn.close()
            
            logger.info("‚úÖ Tabelas de competi√ß√£o inicializadas")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar banco: {e}")
            return False
    
    async def show_competition_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Comando /competicao - Mostra informa√ß√µes da competi√ß√£o ativa
        """
        try:
            user = update.effective_user
            
            # Buscar competi√ß√£o ativa
            active_competition = self.get_active_competition()
            
            if not active_competition:
                await update.message.reply_text(
                    "‚ùå **Nenhuma competi√ß√£o ativa no momento.**\n\n"
                    "üì¢ Aguarde o an√∫ncio da pr√≥xima competi√ß√£o!\n"
                    "üîî Use /help para ver outros comandos dispon√≠veis.",
                    parse_mode='Markdown'
                )
                return
            
            # Buscar estat√≠sticas do usu√°rio
            user_stats = self.get_user_competition_stats(user.id, active_competition['id'])
            
            # Buscar ranking geral
            top_participants = self.get_competition_ranking(active_competition['id'], limit=5)
            
            # Calcular dias restantes
            end_date = datetime.fromisoformat(active_competition['end_date'])
            days_left = (end_date - datetime.now()).days
            
            # Montar resposta
            info_text = f"""
üèÜ **{active_competition['name']}**

üìù **Descri√ß√£o:**
{active_competition['description']}

üìÖ **Per√≠odo:**
üü¢ In√≠cio: {active_competition['start_date'][:10]}
üî¥ Fim: {active_competition['end_date'][:10]}
‚è∞ Dias restantes: **{days_left} dias**

üë§ **Suas Estat√≠sticas:**
üéØ Convites realizados: **{user_stats['invites'] if user_stats else 0}**
üèÖ Sua posi√ß√£o: **#{user_stats['position'] if user_stats else 'N/A'}**

üèÜ **TOP 5 RANKING:**
"""
            
            for i, participant in enumerate(top_participants, 1):
                medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i}¬∫"
                info_text += f"{medal} {participant['first_name']} - {participant['invites']} convites\n"
            
            info_text += f"""
üìä **Comandos √öteis:**
‚Ä¢ /convite - Gerar seu link de convite
‚Ä¢ /ranking - Ver ranking completo
‚Ä¢ /meus_convites - Suas estat√≠sticas detalhadas

üéØ **Dica:** Compartilhe seu link e convide mais pessoas!
"""
            
            await update.message.reply_text(info_text, parse_mode='Markdown')
            logger.info(f"‚úÖ Info da competi√ß√£o mostrada para {user.first_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao mostrar info da competi√ß√£o: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    async def create_competition(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Comando /criar_competicao - Criar nova competi√ß√£o (s√≥ admins)
        """
        try:
            user = update.effective_user
            
            # Verificar se √© admin (voc√™ pode ajustar essa verifica√ß√£o)
            admin_ids = [7874182984, 6440447977, 381199906]  # IDs dos admins
            
            if user.id not in admin_ids:
                await update.message.reply_text("‚ùå Apenas administradores podem criar competi√ß√µes.")
                return
            
            # Verificar argumentos
            if not context.args or len(context.args) < 3:
                help_text = """
üèÜ **CRIAR COMPETI√á√ÉO**

**Uso:** `/criar_competicao "Nome" "Descri√ß√£o" dias_duracao`

**Exemplo:**
`/criar_competicao "Competi√ß√£o de Agosto" "Convide o m√°ximo de pessoas!" 30`

**Par√¢metros:**
‚Ä¢ Nome: Nome da competi√ß√£o (entre aspas)
‚Ä¢ Descri√ß√£o: Descri√ß√£o da competi√ß√£o (entre aspas)  
‚Ä¢ Dias: Dura√ß√£o em dias (n√∫mero)
"""
                await update.message.reply_text(help_text, parse_mode='Markdown')
                return
            
            # Extrair par√¢metros
            args_text = ' '.join(context.args)
            
            # Parse simples dos argumentos
            try:
                # Assumindo formato: "Nome" "Descri√ß√£o" dias
                parts = args_text.split('"')
                if len(parts) >= 5:
                    name = parts[1]
                    description = parts[3]
                    days_str = parts[4].strip()
                    days = int(days_str)
                else:
                    raise ValueError("Formato inv√°lido")
            except:
                await update.message.reply_text(
                    "‚ùå Formato inv√°lido. Use:\n"
                    "`/criar_competicao \"Nome\" \"Descri√ß√£o\" dias`",
                    parse_mode='Markdown'
                )
                return
            
            # Desativar competi√ß√µes ativas
            self.deactivate_all_competitions()
            
            # Criar nova competi√ß√£o
            start_date = datetime.now()
            end_date = start_date + timedelta(days=days)
            
            competition_id = self.create_new_competition(name, description, start_date, end_date)
            
            if competition_id:
                success_text = f"""
‚úÖ **COMPETI√á√ÉO CRIADA COM SUCESSO!**

üèÜ **Nome:** {name}
üìù **Descri√ß√£o:** {description}
üìÖ **In√≠cio:** {start_date.strftime('%d/%m/%Y %H:%M')}
üìÖ **Fim:** {end_date.strftime('%d/%m/%Y %H:%M')}
‚è∞ **Dura√ß√£o:** {days} dias

üöÄ **A competi√ß√£o est√° ativa!**
üì¢ Participantes podem usar /convite para gerar links.
"""
                await update.message.reply_text(success_text, parse_mode='Markdown')
                logger.info(f"‚úÖ Competi√ß√£o criada: {name} por {user.first_name}")
            else:
                await update.message.reply_text("‚ùå Erro ao criar competi√ß√£o. Tente novamente.")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar competi√ß√£o: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    async def end_competition(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Comando /encerrar_competicao - Encerrar competi√ß√£o ativa (s√≥ admins)
        """
        try:
            user = update.effective_user
            
            # Verificar se √© admin
            admin_ids = [7874182984, 6440447977, 381199906]
            
            if user.id not in admin_ids:
                await update.message.reply_text("‚ùå Apenas administradores podem encerrar competi√ß√µes.")
                return
            
            # Buscar competi√ß√£o ativa
            active_competition = self.get_active_competition()
            
            if not active_competition:
                await update.message.reply_text("‚ùå Nenhuma competi√ß√£o ativa para encerrar.")
                return
            
            # Buscar vencedores
            winners = self.get_competition_ranking(active_competition['id'], limit=3)
            
            # Encerrar competi√ß√£o
            if self.end_active_competition(active_competition['id']):
                
                result_text = f"""
üèÅ **COMPETI√á√ÉO ENCERRADA!**

üèÜ **{active_competition['name']}**

ü•á **VENCEDORES:**
"""
                
                for i, winner in enumerate(winners, 1):
                    medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â"
                    result_text += f"{medal} {winner['first_name']} - {winner['invites']} convites\n"
                
                result_text += f"""
üìä **Estat√≠sticas Finais:**
üë• Total de participantes: {len(self.get_all_participants(active_competition['id']))}
üîó Total de convites: {self.get_total_invites(active_competition['id'])}

üéâ **Parab√©ns a todos os participantes!**
"""
                
                await update.message.reply_text(result_text, parse_mode='Markdown')
                logger.info(f"‚úÖ Competi√ß√£o encerrada por {user.first_name}")
            else:
                await update.message.reply_text("‚ùå Erro ao encerrar competi√ß√£o.")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao encerrar competi√ß√£o: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    def get_active_competition(self):
        """
        Retorna competi√ß√£o ativa
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT * FROM competitions 
                WHERE is_active = 1 
                AND datetime('now') BETWEEN start_date AND end_date
                ORDER BY created_at DESC
                LIMIT 1
            """)
            
            competition = cursor.fetchone()
            conn.close()
            
            return dict(competition) if competition else None
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar competi√ß√£o ativa: {e}")
            return None
    
    def get_user_competition_stats(self, user_id, competition_id):
        """
        Retorna estat√≠sticas do usu√°rio na competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            
            # Buscar dados do participante
            cursor.execute("""
                SELECT 
                    cp.invites_count,
                    (SELECT COUNT(*) + 1 FROM competition_participants cp2 
                     WHERE cp2.competition_id = cp.competition_id 
                     AND cp2.invites_count > cp.invites_count) as position
                FROM competition_participants cp
                WHERE cp.user_id = ? AND cp.competition_id = ?
            """, (user_id, competition_id))
            
            stats = cursor.fetchone()
            conn.close()
            
            if stats:
                return {
                    'invites': stats['invites_count'],
                    'position': stats['position']
                }
            else:
                return {'invites': 0, 'position': 'N/A'}
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar estat√≠sticas do usu√°rio: {e}")
            return None
    
    def get_competition_ranking(self, competition_id, limit=10):
        """
        Retorna ranking da competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    cp.invites_count as invites,
                    u.first_name,
                    u.username,
                    u.telegram_id
                FROM competition_participants cp
                JOIN users u ON cp.user_id = u.telegram_id
                WHERE cp.competition_id = ?
                ORDER BY cp.invites_count DESC
                LIMIT ?
            """, (competition_id, limit))
            
            ranking = cursor.fetchall()
            conn.close()
            
            return [dict(row) for row in ranking]
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar ranking: {e}")
            return []
    
    def create_new_competition(self, name, description, start_date, end_date):
        """
        Cria nova competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO competitions (name, description, start_date, end_date, is_active)
                VALUES (?, ?, ?, ?, 1)
            """, (name, description, start_date.isoformat(), end_date.isoformat()))
            
            competition_id = cursor.lastrowid
            conn.commit()
            conn.close()
            
            return competition_id
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar competi√ß√£o: {e}")
            return None
    
    def deactivate_all_competitions(self):
        """
        Desativa todas as competi√ß√µes
        """
        try:
            conn = self.get_connection()
            if not conn:
                return False
            
            cursor = conn.cursor()
            cursor.execute("UPDATE competitions SET is_active = 0")
            conn.commit()
            conn.close()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao desativar competi√ß√µes: {e}")
            return False
    
    def end_active_competition(self, competition_id):
        """
        Encerra competi√ß√£o espec√≠fica
        """
        try:
            conn = self.get_connection()
            if not conn:
                return False
            
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE competitions 
                SET is_active = 0, end_date = datetime('now')
                WHERE id = ?
            """, (competition_id,))
            
            conn.commit()
            conn.close()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao encerrar competi√ß√£o: {e}")
            return False
    
    def get_all_participants(self, competition_id):
        """
        Retorna todos os participantes da competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT cp.*, u.first_name, u.username
                FROM competition_participants cp
                JOIN users u ON cp.user_id = u.telegram_id
                WHERE cp.competition_id = ?
            """, (competition_id,))
            
            participants = cursor.fetchall()
            conn.close()
            
            return [dict(row) for row in participants]
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar participantes: {e}")
            return []
    
    def get_total_invites(self, competition_id):
        """
        Retorna total de convites da competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return 0
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT SUM(invites_count) as total
                FROM competition_participants
                WHERE competition_id = ?
            """, (competition_id,))
            
            result = cursor.fetchone()
            conn.close()
            
            return result['total'] if result['total'] else 0
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao contar convites: {e}")
            return 0
EOF

# Verificar sintaxe
if python3 -m py_compile "$COMPETITION_FILE" 2>/dev/null; then
    log_success "Sistema de competi√ß√µes criado com sucesso"
else
    log_error "Erro no sistema de competi√ß√µes"
fi

echo ""
echo "üèÜ PASSO 3: Criar ranking_commands.py completo"
echo "=============================================="

RANKING_FILE="src/bot/handlers/ranking_commands.py"

log_info "Fazendo backup do ranking_commands atual..."
cp "$RANKING_FILE" "${RANKING_FILE}.before_restore.backup" 2>/dev/null || true

log_info "Criando sistema completo de ranking..."

cat > "$RANKING_FILE" << 'EOF'
"""
Ranking Commands - Sistema Completo
Sistema completo de ranking para competi√ß√µes
"""

import logging
from datetime import datetime
import sqlite3
from telegram import Update
from telegram.ext import ContextTypes

logger = logging.getLogger(__name__)

class RankingCommands:
    """
    Sistema completo de comandos de ranking
    """
    
    def __init__(self):
        self.db_path = "bot_database.db"
    
    def get_connection(self):
        """
        Retorna conex√£o com banco
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        except Exception as e:
            logger.error(f"Erro ao conectar: {e}")
            return None
    
    async def show_ranking(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Comando /ranking - Mostra ranking da competi√ß√£o ativa
        """
        try:
            user = update.effective_user
            
            # Buscar competi√ß√£o ativa
            active_competition = self.get_active_competition()
            
            if not active_competition:
                await update.message.reply_text(
                    "‚ùå **Nenhuma competi√ß√£o ativa no momento.**\n\n"
                    "üì¢ Aguarde o an√∫ncio da pr√≥xima competi√ß√£o!\n"
                    "üîî Use /help para ver outros comandos dispon√≠veis.",
                    parse_mode='Markdown'
                )
                return
            
            # Buscar ranking completo
            participants = self.get_competition_ranking(active_competition['id'], limit=20)
            
            if not participants:
                await update.message.reply_text(
                    f"üìä **RANKING - {active_competition['name']}**\n\n"
                    "‚ùå Nenhum participante ainda.\n\n"
                    "üéØ Seja o primeiro! Use /convite para gerar seu link.",
                    parse_mode='Markdown'
                )
                return
            
            # Buscar posi√ß√£o do usu√°rio
            user_position = self.get_user_position(user.id, active_competition['id'])
            
            # Montar ranking
            ranking_text = f"""
üèÜ **RANKING - {active_competition['name']}**

üìä **TOP 20 PARTICIPANTES:**

"""
            
            for i, participant in enumerate(participants, 1):
                medal = ""
                if i == 1:
                    medal = "ü•á"
                elif i == 2:
                    medal = "ü•à"
                elif i == 3:
                    medal = "ü•â"
                else:
                    medal = f"{i:2d}¬∫"
                
                # Destacar o usu√°rio atual
                highlight = "üë§" if participant['telegram_id'] == user.id else "  "
                
                name = participant['first_name'] or "Usu√°rio"
                invites = participant['invites']
                
                ranking_text += f"{medal} {highlight} {name} - {invites} convites\n"
            
            # Adicionar informa√ß√µes do usu√°rio
            if user_position:
                ranking_text += f"""

üë§ **SUA POSI√á√ÉO:**
üèÖ Posi√ß√£o: #{user_position['position']}
üéØ Convites: {user_position['invites']}
"""
            else:
                ranking_text += f"""

üë§ **VOC√ä:**
‚ùå Ainda n√£o est√° participando.
üéØ Use /convite para gerar seu link!
"""
            
            # Adicionar estat√≠sticas gerais
            total_participants = len(participants)
            total_invites = sum(p['invites'] for p in participants)
            
            ranking_text += f"""

üìà **ESTAT√çSTICAS GERAIS:**
üë• Total de participantes: {total_participants}
üîó Total de convites: {total_invites}

üéØ **Comandos √öteis:**
‚Ä¢ /convite - Gerar seu link
‚Ä¢ /competicao - Info da competi√ß√£o
‚Ä¢ /meus_convites - Suas estat√≠sticas
"""
            
            await update.message.reply_text(ranking_text, parse_mode='Markdown')
            logger.info(f"‚úÖ Ranking mostrado para {user.first_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao mostrar ranking: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    async def show_my_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Comando /meus_convites - Mostra estat√≠sticas detalhadas do usu√°rio
        """
        try:
            user = update.effective_user
            
            # Buscar competi√ß√£o ativa
            active_competition = self.get_active_competition()
            
            if not active_competition:
                await update.message.reply_text(
                    "‚ùå Nenhuma competi√ß√£o ativa no momento.",
                    parse_mode='Markdown'
                )
                return
            
            # Buscar estat√≠sticas detalhadas
            user_stats = self.get_detailed_user_stats(user.id, active_competition['id'])
            
            if not user_stats:
                stats_text = f"""
üìä **SUAS ESTAT√çSTICAS**

üèÜ **Competi√ß√£o:** {active_competition['name']}

‚ùå **Voc√™ ainda n√£o est√° participando.**

üéØ **Como participar:**
1. Use /convite para gerar seu link
2. Compartilhe com seus amigos
3. Ganhe pontos quando eles entrarem
4. Acompanhe sua posi√ß√£o no /ranking

üöÄ **Comece agora!**
"""
            else:
                stats_text = f"""
üìä **SUAS ESTAT√çSTICAS**

üèÜ **Competi√ß√£o:** {active_competition['name']}

üèÖ **Sua Posi√ß√£o:** #{user_stats['position']}
üéØ **Convites Realizados:** {user_stats['invites']}
üìÖ **Participando desde:** {user_stats['joined_at'][:10]}

üîó **Seu Link Ativo:** 
{user_stats['invite_link'] if user_stats['invite_link'] else 'Nenhum link ativo'}

üìà **Progresso:**
"""
                
                # Calcular dist√¢ncia para pr√≥ximas posi√ß√µes
                next_positions = self.get_positions_above(user_stats['position'], active_competition['id'])
                
                for pos_info in next_positions[:3]:
                    diff = pos_info['invites'] - user_stats['invites']
                    if diff > 0:
                        stats_text += f"‚Ä¢ Para #{pos_info['position']}: +{diff} convites\n"
                
                stats_text += f"""

üéØ **Dicas:**
‚Ä¢ Compartilhe seu link em grupos
‚Ä¢ Convide amigos e familiares
‚Ä¢ Use redes sociais
‚Ä¢ Seja criativo na divulga√ß√£o!

üìä Use /ranking para ver o ranking completo.
"""
            
            await update.message.reply_text(stats_text, parse_mode='Markdown')
            logger.info(f"‚úÖ Estat√≠sticas mostradas para {user.first_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao mostrar estat√≠sticas: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    def get_active_competition(self):
        """
        Retorna competi√ß√£o ativa
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT * FROM competitions 
                WHERE is_active = 1 
                AND datetime('now') BETWEEN start_date AND end_date
                ORDER BY created_at DESC
                LIMIT 1
            """)
            
            competition = cursor.fetchone()
            conn.close()
            
            return dict(competition) if competition else None
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar competi√ß√£o ativa: {e}")
            return None
    
    def get_competition_ranking(self, competition_id, limit=20):
        """
        Retorna ranking da competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    cp.invites_count as invites,
                    u.first_name,
                    u.username,
                    u.telegram_id
                FROM competition_participants cp
                JOIN users u ON cp.user_id = u.telegram_id
                WHERE cp.competition_id = ?
                ORDER BY cp.invites_count DESC, cp.joined_at ASC
                LIMIT ?
            """, (competition_id, limit))
            
            ranking = cursor.fetchall()
            conn.close()
            
            return [dict(row) for row in ranking]
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar ranking: {e}")
            return []
    
    def get_user_position(self, user_id, competition_id):
        """
        Retorna posi√ß√£o do usu√°rio na competi√ß√£o
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    cp.invites_count as invites,
                    (SELECT COUNT(*) + 1 FROM competition_participants cp2 
                     WHERE cp2.competition_id = cp.competition_id 
                     AND (cp2.invites_count > cp.invites_count 
                          OR (cp2.invites_count = cp.invites_count AND cp2.joined_at < cp.joined_at))
                    ) as position
                FROM competition_participants cp
                WHERE cp.user_id = ? AND cp.competition_id = ?
            """, (user_id, competition_id))
            
            result = cursor.fetchone()
            conn.close()
            
            return dict(result) if result else None
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar posi√ß√£o do usu√°rio: {e}")
            return None
    
    def get_detailed_user_stats(self, user_id, competition_id):
        """
        Retorna estat√≠sticas detalhadas do usu√°rio
        """
        try:
            conn = self.get_connection()
            if not conn:
                return None
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    cp.invites_count as invites,
                    cp.joined_at,
                    (SELECT COUNT(*) + 1 FROM competition_participants cp2 
                     WHERE cp2.competition_id = cp.competition_id 
                     AND (cp2.invites_count > cp.invites_count 
                          OR (cp2.invites_count = cp.invites_count AND cp2.joined_at < cp.joined_at))
                    ) as position,
                    il.invite_link
                FROM competition_participants cp
                LEFT JOIN invite_links il ON cp.user_id = il.user_id 
                    AND il.competition_id = cp.competition_id 
                    AND il.is_active = 1
                WHERE cp.user_id = ? AND cp.competition_id = ?
            """, (user_id, competition_id))
            
            result = cursor.fetchone()
            conn.close()
            
            return dict(result) if result else None
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar estat√≠sticas detalhadas: {e}")
            return None
    
    def get_positions_above(self, current_position, competition_id, limit=5):
        """
        Retorna posi√ß√µes acima da atual
        """
        try:
            conn = self.get_connection()
            if not conn:
                return []
            
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    cp.invites_count as invites,
                    (SELECT COUNT(*) + 1 FROM competition_participants cp2 
                     WHERE cp2.competition_id = cp.competition_id 
                     AND (cp2.invites_count > cp.invites_count 
                          OR (cp2.invites_count = cp.invites_count AND cp2.joined_at < cp.joined_at))
                    ) as position
                FROM competition_participants cp
                WHERE cp.competition_id = ?
                AND (SELECT COUNT(*) + 1 FROM competition_participants cp2 
                     WHERE cp2.competition_id = cp.competition_id 
                     AND (cp2.invites_count > cp.invites_count 
                          OR (cp2.invites_count = cp.invites_count AND cp2.joined_at < cp.joined_at))
                    ) < ?
                ORDER BY cp.invites_count DESC
                LIMIT ?
            """, (competition_id, current_position, limit))
            
            positions = cursor.fetchall()
            conn.close()
            
            return [dict(row) for row in positions]
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar posi√ß√µes acima: {e}")
            return []
EOF

# Verificar sintaxe
if python3 -m py_compile "$RANKING_FILE" 2>/dev/null; then
    log_success "Sistema de ranking criado com sucesso"
else
    log_error "Erro no sistema de ranking"
fi

echo ""
echo "üîß PASSO 4: Atualizar bot_manager.py com novos comandos"
echo "======================================================"

BOT_MANAGER_FILE="src/bot/bot_manager.py"

log_info "Fazendo backup do bot_manager atual..."
cp "$BOT_MANAGER_FILE" "${BOT_MANAGER_FILE}.before_competition_restore.backup" 2>/dev/null || true

log_info "Atualizando bot_manager com comandos de competi√ß√£o..."

cat > "$BOT_MANAGER_FILE" << 'EOF'
"""
Bot Manager - Com Sistema de Competi√ß√µes Completo
Sistema completo com competi√ß√µes funcionais
"""

import logging
from telegram.ext import Application, CommandHandler, MessageHandler, filters
from src.config.settings import settings

# Imports dos m√≥dulos
try:
    from src.bot.handlers.invite_commands import InviteCommands
    invite_commands_available = True
except ImportError:
    invite_commands_available = False

try:
    from src.bot.handlers.competition_commands import CompetitionCommands
    competition_commands_available = True
except ImportError:
    competition_commands_available = False

try:
    from src.bot.handlers.ranking_commands import RankingCommands
    ranking_commands_available = True
except ImportError:
    ranking_commands_available = False

# Configurar logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class BotManager:
    """
    Gerenciador do bot com sistema de competi√ß√µes completo
    """
    
    def __init__(self):
        self.application = None
        
        # Inicializar m√≥dulos
        self.invite_commands = InviteCommands() if invite_commands_available else None
        self.competition_commands = CompetitionCommands() if competition_commands_available else None
        self.ranking_commands = RankingCommands() if ranking_commands_available else None
        
        logger.info("ü§ñ Bot Manager inicializado com sistema de competi√ß√µes")
        logger.info(f"üì¶ M√≥dulos dispon√≠veis:")
        logger.info(f"   - InviteCommands: {'‚úÖ' if invite_commands_available else '‚ùå'}")
        logger.info(f"   - CompetitionCommands: {'‚úÖ' if competition_commands_available else '‚ùå'}")
        logger.info(f"   - RankingCommands: {'‚úÖ' if ranking_commands_available else '‚ùå'}")
    
    def setup_handlers(self):
        """
        Configura handlers do bot
        """
        try:
            # Handlers b√°sicos
            self.application.add_handler(CommandHandler("start", self.start_command))
            self.application.add_handler(CommandHandler("help", self.help_command))
            
            # Handlers de convite
            if self.invite_commands:
                self.application.add_handler(CommandHandler("convite", self.invite_commands.create_invite_link))
                logger.info("‚úÖ Handler /convite adicionado")
            
            # Handlers de competi√ß√£o
            if self.competition_commands:
                self.application.add_handler(CommandHandler("competicao", self.competition_commands.show_competition_info))
                self.application.add_handler(CommandHandler("criar_competicao", self.competition_commands.create_competition))
                self.application.add_handler(CommandHandler("encerrar_competicao", self.competition_commands.end_competition))
                logger.info("‚úÖ Handlers de competi√ß√£o adicionados")
            
            # Handlers de ranking
            if self.ranking_commands:
                self.application.add_handler(CommandHandler("ranking", self.ranking_commands.show_ranking))
                self.application.add_handler(CommandHandler("meus_convites", self.ranking_commands.show_my_stats))
                logger.info("‚úÖ Handlers de ranking adicionados")
            
            # Handler para novos membros
            self.application.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, self.handle_new_member))
            
            logger.info("‚úÖ Todos os handlers configurados com sucesso")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao configurar handlers: {e}")
    
    async def start_command(self, update, context):
        """
        Comando /start
        """
        try:
            user = update.effective_user
            welcome_text = f"""
üéâ Ol√° {user.first_name}!

Bem-vindo ao bot de competi√ß√µes do Palpite em Casa!

üèÜ **COMANDOS DE COMPETI√á√ÉO:**
‚Ä¢ /competicao - Ver competi√ß√£o ativa
‚Ä¢ /ranking - Ver ranking atual
‚Ä¢ /convite - Gerar seu link de convite
‚Ä¢ /meus_convites - Suas estat√≠sticas

üëë **COMANDOS ADMIN:**
‚Ä¢ /criar_competicao - Criar nova competi√ß√£o
‚Ä¢ /encerrar_competicao - Encerrar competi√ß√£o

‚ùì **OUTROS:**
‚Ä¢ /help - Ajuda detalhada

üéØ Participe da competi√ß√£o e convide seus amigos!
"""
            await update.message.reply_text(welcome_text)
            logger.info(f"‚úÖ Comando /start executado para {user.first_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro no comando start: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    async def help_command(self, update, context):
        """
        Comando /help
        """
        try:
            help_text = """
üìã **COMANDOS DISPON√çVEIS:**

üèÜ **COMPETI√á√ÉO:**
‚Ä¢ /competicao - Informa√ß√µes da competi√ß√£o ativa
‚Ä¢ /ranking - Ver ranking completo
‚Ä¢ /convite - Gerar seu link de convite personalizado
‚Ä¢ /meus_convites - Suas estat√≠sticas detalhadas

üëë **ADMINISTRA√á√ÉO (s√≥ admins):**
‚Ä¢ /criar_competicao "Nome" "Descri√ß√£o" dias
‚Ä¢ /encerrar_competicao - Encerrar competi√ß√£o ativa

üí° **COMO FUNCIONA:**
1. Use /competicao para ver se h√° competi√ß√£o ativa
2. Use /convite para gerar seu link personalizado
3. Compartilhe seu link com amigos e familiares
4. Ganhe pontos quando pessoas entrarem pelo seu link
5. Acompanhe sua posi√ß√£o no /ranking
6. Ven√ßa a competi√ß√£o sendo o que mais convidou!

üéØ **DICAS PARA GANHAR:**
‚Ä¢ Compartilhe em grupos do WhatsApp
‚Ä¢ Poste nas redes sociais
‚Ä¢ Convide amigos e familiares
‚Ä¢ Seja criativo na divulga√ß√£o!

üèÜ **Boa sorte na competi√ß√£o!**
"""
            await update.message.reply_text(help_text, parse_mode='Markdown')
            logger.info(f"‚úÖ Comando /help executado")
            
        except Exception as e:
            logger.error(f"‚ùå Erro no comando help: {e}")
            await update.message.reply_text("‚ùå Erro interno. Tente novamente.")
    
    async def handle_new_member(self, update, context):
        """
        Handler para novos membros
        """
        try:
            new_members = update.message.new_chat_members
            
            for member in new_members:
                if not member.is_bot:
                    logger.info(f"‚úÖ Novo membro: {member.first_name} (ID: {member.id})")
                    
                    welcome_text = f"""
üéâ Bem-vindo ao grupo, {member.first_name}!

üèÜ **H√° uma competi√ß√£o ativa!**
‚Ä¢ Use /competicao para ver detalhes
‚Ä¢ Use /convite para gerar seu link
‚Ä¢ Use /ranking para ver sua posi√ß√£o

üéØ Participe e convide seus amigos!
"""
                    await update.message.reply_text(welcome_text, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao processar novo membro: {e}")
    
    def run(self):
        """
        Executa o bot
        """
        try:
            # Criar aplica√ß√£o
            self.application = Application.builder().token(settings.BOT_TOKEN).build()
            
            # Configurar handlers
            self.setup_handlers()
            
            logger.info("üöÄ Iniciando bot com sistema de competi√ß√µes...")
            logger.info(f"ü§ñ Bot Token: {settings.BOT_TOKEN[:10]}...")
            logger.info(f"üí¨ Chat ID: {settings.CHAT_ID}")
            logger.info(f"üë• Admin IDs: {len(settings.ADMIN_IDS)} configurados")
            
            # Executar bot
            logger.info("üéØ Bot iniciado com sistema de competi√ß√µes completo!")
            self.application.run_polling(drop_pending_updates=True)
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao executar bot: {e}")
            raise

# Inst√¢ncia global
bot_manager = BotManager()
EOF

# Verificar sintaxe
if python3 -m py_compile "$BOT_MANAGER_FILE" 2>/dev/null; then
    log_success "Bot Manager com competi√ß√µes criado com sucesso"
else
    log_error "Erro no Bot Manager com competi√ß√µes"
fi

echo ""
echo "üß™ PASSO 5: Testar sistema completo"
echo "==================================="

log_info "Ativando ambiente virtual..."
source venv/bin/activate

log_info "Testando import do competition_commands..."
python3 -c "
import sys
sys.path.insert(0, 'src')
try:
    from src.bot.handlers.competition_commands import CompetitionCommands
    print('‚úÖ Competition Commands OK')
except Exception as e:
    print(f'‚ùå Erro Competition Commands: {e}')
    sys.exit(1)
"

if [ $? -eq 0 ]; then
    log_success "Competition Commands OK"
else
    log_error "Erro persistente em Competition Commands"
    exit 1
fi

log_info "Testando import do ranking_commands..."
python3 -c "
import sys
sys.path.insert(0, 'src')
try:
    from src.bot.handlers.ranking_commands import RankingCommands
    print('‚úÖ Ranking Commands OK')
except Exception as e:
    print(f'‚ùå Erro Ranking Commands: {e}')
    sys.exit(1)
"

if [ $? -eq 0 ]; then
    log_success "Ranking Commands OK"
else
    log_error "Erro persistente em Ranking Commands"
    exit 1
fi

log_info "Testando import do bot_manager completo..."
python3 -c "
import sys
sys.path.insert(0, 'src')
try:
    from src.bot.bot_manager import bot_manager
    print('‚úÖ Bot Manager Completo OK')
except Exception as e:
    print(f'‚ùå Erro Bot Manager: {e}')
    sys.exit(1)
"

if [ $? -eq 0 ]; then
    log_success "Bot Manager Completo OK"
else
    log_error "Erro persistente em Bot Manager"
    exit 1
fi

log_info "Testando import do main.py..."
python3 -c "
import sys
try:
    import main
    print('‚úÖ Main.py OK')
except Exception as e:
    print(f'‚ùå Erro Main: {e}')
    sys.exit(1)
"

if [ $? -eq 0 ]; then
    log_success "Main.py OK"
else
    log_error "Erro persistente em Main.py"
    exit 1
fi

echo ""
echo "üöÄ PASSO 6: Iniciar servi√ßo"
echo "==========================="

log_info "Iniciando servi√ßo telegram-bot..."
systemctl start telegram-bot

# Aguardar inicializa√ß√£o
sleep 30

# Verificar status
if systemctl is-active --quiet telegram-bot; then
    log_success "Servi√ßo iniciado com sucesso"
    
    log_info "Status do servi√ßo:"
    systemctl status telegram-bot --no-pager -l
    
else
    log_error "Falha ao iniciar servi√ßo"
    log_error "Logs de erro:"
    journalctl -u telegram-bot --no-pager -n 25
fi

echo ""
echo "üîç PASSO 7: Verifica√ß√£o final completa"
echo "======================================"

log_info "Executando verifica√ß√£o final..."
echo "ü§ñ Bot: $(systemctl is-active telegram-bot)"
echo "üêò PostgreSQL: $(systemctl is-active postgresql)"

# Verificar se h√° erros recentes
ERROR_COUNT=$(journalctl -u telegram-bot --since "5 minutes ago" | grep -i error | wc -l)
if [ "$ERROR_COUNT" -eq 0 ]; then
    log_success "Nenhum erro nos √∫ltimos 5 minutos"
else
    log_error "$ERROR_COUNT erros encontrados nos √∫ltimos 5 minutos"
    journalctl -u telegram-bot --since "5 minutes ago" | grep -i error | tail -5
fi

# Verificar se bot est√° respondendo
log_info "Testando conectividade do bot..."
python3 -c "
import sys
sys.path.insert(0, 'src')
try:
    from src.config.settings import settings
    import requests
    
    url = f'https://api.telegram.org/bot{settings.BOT_TOKEN}/getMe'
    response = requests.get(url, timeout=10)
    
    if response.status_code == 200:
        data = response.json()
        if data.get('ok'):
            print(f'‚úÖ Bot respondendo: @{data[\"result\"][\"username\"]}')
        else:
            print('‚ùå Bot n√£o est√° respondendo corretamente')
    else:
        print(f'‚ùå Erro HTTP: {response.status_code}')
        
except Exception as e:
    print(f'‚ùå Erro ao testar bot: {e}')
"

echo ""
echo "üèÜ RESUMO FINAL - SISTEMA DE COMPETI√á√ïES"
echo "========================================"

BOT_STATUS=$(systemctl is-active telegram-bot)
POSTGRES_STATUS=$(systemctl is-active postgresql)

echo "ü§ñ Status do Bot: $BOT_STATUS"
echo "üêò Status PostgreSQL: $POSTGRES_STATUS"

if [ "$BOT_STATUS" = "active" ]; then
    echo -e "${GREEN}üéâ SISTEMA DE COMPETI√á√ïES 100% FUNCIONAL!${NC}"
    echo "üöÄ Bot est√° operacional"
    echo "‚öôÔ∏è Settings completo"
    echo "üèÜ Sistema de competi√ß√µes ativo"
    echo "üìä Sistema de ranking ativo"
    echo "üîó Sistema de convites ativo"
    echo "‚úÖ Todos os m√≥dulos funcionando"
    
    echo ""
    echo "üèÜ COMANDOS DE COMPETI√á√ÉO DISPON√çVEIS:"
    echo "‚Ä¢ /competicao - Ver competi√ß√£o ativa"
    echo "‚Ä¢ /ranking - Ver ranking completo"
    echo "‚Ä¢ /convite - Gerar link de convite"
    echo "‚Ä¢ /meus_convites - Estat√≠sticas pessoais"
    
    echo ""
    echo "üëë COMANDOS ADMINISTRATIVOS:"
    echo "‚Ä¢ /criar_competicao \"Nome\" \"Descri√ß√£o\" dias"
    echo "‚Ä¢ /encerrar_competicao - Encerrar competi√ß√£o"
    
    echo ""
    echo "üìû COMANDOS B√ÅSICOS:"
    echo "‚Ä¢ /start - Boas-vindas"
    echo "‚Ä¢ /help - Ajuda completa"
    
    echo ""
    echo "üìû COMANDOS √öTEIS DO SISTEMA:"
    echo "‚Ä¢ Ver logs: journalctl -u telegram-bot -f"
    echo "‚Ä¢ Status: systemctl status telegram-bot"
    echo "‚Ä¢ Parar: systemctl stop telegram-bot"
    echo "‚Ä¢ Iniciar: systemctl start telegram-bot"
    
    echo ""
    echo "üéØ SISTEMA COMPLETO PRONTO PARA PRODU√á√ÉO!"
    echo "‚úÖ Bot @Porteiropalpite_bot funcionando"
    echo "‚úÖ Sistema de competi√ß√µes completo"
    echo "‚úÖ Sistema de ranking funcional"
    echo "‚úÖ Sistema de convites ativo"
    echo "‚úÖ Comandos administrativos operacionais"
    echo "‚úÖ Banco de dados inicializado"
    
    echo ""
    echo "üèÜ PARAB√âNS! SISTEMA DE COMPETI√á√ïES RESTAURADO!"
    echo "üéâ Bot totalmente operacional!"
    echo "üöÄ Sistema completo e funcional!"
    echo "üèÜ Competi√ß√µes funcionando como antes!"
    echo "‚úÖ Todos os comandos operacionais!"
    
    echo ""
    echo "üéäüéäüéä SISTEMA DE COMPETI√á√ïES CONCLU√çDO! üéäüéäüéä"
    echo "üèÜüèÜüèÜ COMPETI√á√ïES 100% FUNCIONAIS! üèÜüèÜüèÜ"
    echo "üöÄüöÄüöÄ BOT COMPLETO OPERACIONAL! üöÄüöÄüöÄ"
    
else
    echo -e "${RED}‚ùå AINDA H√Å PROBLEMAS${NC}"
    echo "üîß Verifique os logs para mais detalhes:"
    echo "journalctl -u telegram-bot -n 30"
fi

echo ""
echo "üìÖ Sistema de competi√ß√µes restaurado em: $(date)"
echo "==============================================="
EOF

