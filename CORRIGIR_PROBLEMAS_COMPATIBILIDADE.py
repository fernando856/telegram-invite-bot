#!/usr/bin/env python3
"""
Script de Corre√ß√£o Autom√°tica de Problemas de Compatibilidade
Corrige automaticamente os 699 problemas cr√≠ticos encontrados na auditoria
"""
import os
import re
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Set
from datetime import datetime
import json

class CompatibilityFixer:
    """
    Corretor autom√°tico de problemas de compatibilidade
    Aplica corre√ß√µes baseadas na auditoria realizada
    """
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.backup_dir = self.project_root / "backup_pre_migration"
        
        # Mapeamento de tabelas SQLite ‚Üí PostgreSQL
        self.table_mapping = {
            'users': 'users_global',
            'competitions': 'competitions_global',
            'competition_participants': 'competition_participants_global',
            'invite_links': 'invite_links_global',
            'unique_invited_users': 'global_unique_invited_users',
            'user_actions_log': 'user_actions_log_global',
            'fraud_detection_log': 'fraud_detection_log_global'
        }
        
        # Mapeamento de colunas que mudaram
        self.column_mapping = {
            'current_uses': 'uses',
            'max_uses': 'max_uses',  # mantido
            'uses': 'uses',  # mantido
        }
        
        # Padr√µes de corre√ß√£o SQL
        self.sql_corrections = [
            (r'\bAUTOINCREMENT\b', 'SERIAL'),
            (r'\bINTEGER PRIMARY KEY\b', 'BIGSERIAL PRIMARY KEY'),
            (r'\bDATETIME\b', 'TIMESTAMP WITH TIME ZONE'),
            (r'\bREAL\b', 'DECIMAL'),
            (r'database\.db', 'postgresql://user:pass@localhost/dbname'),
            (r'sqlite3\.connect\(["\']database\.db["\']\)', 'postgresql_connection()'),
        ]
        
        # Imports que precisam ser atualizados
        self.import_corrections = [
            ('import sqlite3', 'from sqlalchemy import create_engine, text'),
            ('from sqlite3 import', '# from sqlite3 import  # MIGRADO PARA POSTGRESQL'),
            ('sqlite3.connect', 'postgresql_connection'),
        ]
        
        # Estat√≠sticas de corre√ß√£o
        self.correction_stats = {
            'files_processed': 0,
            'files_modified': 0,
            'table_corrections': 0,
            'column_corrections': 0,
            'sql_corrections': 0,
            'import_corrections': 0,
            'backup_created': False,
            'errors': []
        }
    
    def fix_all_compatibility_issues(self) -> Dict:
        """
        Executa todas as corre√ß√µes de compatibilidade
        M√âTODO PRINCIPAL
        """
        print("üîß INICIANDO CORRE√á√ÉO AUTOM√ÅTICA DE COMPATIBILIDADE")
        print("=" * 60)
        
        try:
            # 1. Criar backup
            self._create_backup()
            
            # 2. Buscar arquivos Python
            python_files = list(self.project_root.rglob("*.py"))
            python_files = [f for f in python_files if self._should_process_file(f)]
            
            print(f"üìÅ Processando {len(python_files)} arquivos Python...")
            
            # 3. Processar cada arquivo
            for file_path in python_files:
                self._process_file(file_path)
            
            # 4. Criar arquivo de configura√ß√£o PostgreSQL
            self._create_postgresql_config()
            
            # 5. Gerar relat√≥rio
            return self._generate_correction_report()
            
        except Exception as e:
            self.correction_stats['errors'].append(f"Erro geral: {e}")
            print(f"‚ùå ERRO: {e}")
            return self.correction_stats
    
    def _create_backup(self):
        """Cria backup completo antes das corre√ß√µes"""
        print("üíæ Criando backup de seguran√ßa...")
        
        if self.backup_dir.exists():
            shutil.rmtree(self.backup_dir)
        
        # Copiar arquivos importantes
        important_files = [
            "src/",
            "main.py",
            "requirements.txt",
            ".env",
            "bot_database.db"
        ]
        
        self.backup_dir.mkdir(exist_ok=True)
        
        for item in important_files:
            source = self.project_root / item
            if source.exists():
                if source.is_dir():
                    shutil.copytree(source, self.backup_dir / item)
                else:
                    shutil.copy2(source, self.backup_dir / item)
        
        self.correction_stats['backup_created'] = True
        print(f"‚úÖ Backup criado em: {self.backup_dir}")
    
    def _should_process_file(self, file_path: Path) -> bool:
        """Verifica se arquivo deve ser processado"""
        skip_patterns = [
            '__pycache__',
            '.git',
            'venv',
            'env',
            '.pytest_cache',
            'backup_pre_migration',
            'AUDITORIA_COMPATIBILIDADE',
            'CORRIGIR_PROBLEMAS_COMPATIBILIDADE'
        ]
        
        return not any(pattern in str(file_path) for pattern in skip_patterns)
    
    def _process_file(self, file_path: Path):
        """Processa um arquivo aplicando corre√ß√µes"""
        try:
            # Ler arquivo
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            modified_content = original_content
            file_modified = False
            
            # Aplicar corre√ß√µes de tabelas
            for old_table, new_table in self.table_mapping.items():
                # Padr√µes mais espec√≠ficos para evitar falsos positivos
                patterns = [
                    rf'\bFROM\s+{old_table}\b',
                    rf'\bINTO\s+{old_table}\b',
                    rf'\bUPDATE\s+{old_table}\b',
                    rf'\bJOIN\s+{old_table}\b',
                    rf'["\']?{old_table}["\']?',
                    rf'table_name\s*=\s*["\']?{old_table}["\']?'
                ]
                
                for pattern in patterns:
                    if re.search(pattern, modified_content, re.IGNORECASE):
                        # Substitui√ß√£o mais cuidadosa
                        new_content = re.sub(
                            pattern, 
                            lambda m: m.group(0).replace(old_table, new_table),
                            modified_content,
                            flags=re.IGNORECASE
                        )
                        
                        if new_content != modified_content:
                            modified_content = new_content
                            file_modified = True
                            self.correction_stats['table_corrections'] += 1
            
            # Aplicar corre√ß√µes de colunas
            for old_col, new_col in self.column_mapping.items():
                if old_col != new_col:  # S√≥ se realmente mudou
                    pattern = rf'\b{old_col}\b'
                    if re.search(pattern, modified_content):
                        modified_content = re.sub(pattern, new_col, modified_content)
                        file_modified = True
                        self.correction_stats['column_corrections'] += 1
            
            # Aplicar corre√ß√µes SQL
            for old_sql, new_sql in self.sql_corrections:
                if re.search(old_sql, modified_content, re.IGNORECASE):
                    modified_content = re.sub(old_sql, new_sql, modified_content, flags=re.IGNORECASE)
                    file_modified = True
                    self.correction_stats['sql_corrections'] += 1
            
            # Aplicar corre√ß√µes de imports
            for old_import, new_import in self.import_corrections:
                if old_import in modified_content:
                    modified_content = modified_content.replace(old_import, new_import)
                    file_modified = True
                    self.correction_stats['import_corrections'] += 1
            
            # Salvar se modificado
            if file_modified:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(modified_content)
                
                self.correction_stats['files_modified'] += 1
                print(f"‚úÖ Corrigido: {file_path}")
            
            self.correction_stats['files_processed'] += 1
            
        except Exception as e:
            error_msg = f"Erro ao processar {file_path}: {e}"
            self.correction_stats['errors'].append(error_msg)
            print(f"‚ùå {error_msg}")
    
    def _create_postgresql_config(self):
        """Cria arquivo de configura√ß√£o PostgreSQL"""
        config_content = '''"""
Configura√ß√£o PostgreSQL para Migra√ß√£o
Substitui conex√µes SQLite por PostgreSQL
"""
import os
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from src.config.settings import settings

class PostgreSQLConnection:
    """Classe para gerenciar conex√µes PostgreSQL"""
    
    def __init__(self):
        self.database_url = settings.DATABASE_URL
        self.engine = create_engine(self.database_url, echo=False)
        self.SessionLocal = sessionmaker(bind=self.engine)
    
    def get_connection(self):
        """Retorna conex√£o PostgreSQL"""
        return self.engine.connect()
    
    def get_session(self):
        """Retorna sess√£o SQLAlchemy"""
        return self.SessionLocal()
    
    async def execute_query(self, query: str, params: dict = None):
        """Executa query PostgreSQL"""
        with self.get_connection() as conn:
            result = conn.execute(text(query), params or {})
            return result.fetchall()

# Inst√¢ncia global
postgresql_connection = PostgreSQLConnection()

def get_db_connection():
    """Fun√ß√£o compat√≠vel para substituir sqlite3.connect"""
    return postgresql_connection.get_connection()

def get_db_session():
    """Fun√ß√£o para obter sess√£o do banco"""
    return postgresql_connection.get_session()
'''
        
        config_path = self.project_root / "src" / "database" / "postgresql_connection.py"
        config_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(config_path, 'w', encoding='utf-8') as f:
            f.write(config_content)
        
        print(f"‚úÖ Configura√ß√£o PostgreSQL criada: {config_path}")
    
    def _generate_correction_report(self) -> Dict:
        """Gera relat√≥rio de corre√ß√µes aplicadas"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'summary': {
                'files_processed': self.correction_stats['files_processed'],
                'files_modified': self.correction_stats['files_modified'],
                'total_corrections': (
                    self.correction_stats['table_corrections'] +
                    self.correction_stats['column_corrections'] +
                    self.correction_stats['sql_corrections'] +
                    self.correction_stats['import_corrections']
                )
            },
            'corrections_by_type': {
                'table_corrections': self.correction_stats['table_corrections'],
                'column_corrections': self.correction_stats['column_corrections'],
                'sql_corrections': self.correction_stats['sql_corrections'],
                'import_corrections': self.correction_stats['import_corrections']
            },
            'backup_created': self.correction_stats['backup_created'],
            'errors': self.correction_stats['errors'],
            'status': 'success' if not self.correction_stats['errors'] else 'with_errors'
        }
        
        return report
    
    def generate_detailed_report(self, report_data: Dict) -> str:
        """Gera relat√≥rio detalhado em markdown"""
        total_corrections = report_data['summary']['total_corrections']
        
        report_md = f"""# üîß RELAT√ìRIO DE CORRE√á√ÉO DE COMPATIBILIDADE

## üìä Resumo Executivo
- **Timestamp:** {report_data['timestamp']}
- **Status:** {'‚úÖ SUCESSO' if report_data['status'] == 'success' else '‚ö†Ô∏è COM ERROS'}
- **Arquivos Processados:** {report_data['summary']['files_processed']}
- **Arquivos Modificados:** {report_data['summary']['files_modified']}
- **Total de Corre√ß√µes:** {total_corrections}

## üîÑ Corre√ß√µes Aplicadas

### üìã Por Tipo de Corre√ß√£o
- **Tabelas:** {report_data['corrections_by_type']['table_corrections']} corre√ß√µes
- **Colunas:** {report_data['corrections_by_type']['column_corrections']} corre√ß√µes  
- **SQL:** {report_data['corrections_by_type']['sql_corrections']} corre√ß√µes
- **Imports:** {report_data['corrections_by_type']['import_corrections']} corre√ß√µes

### üóÉÔ∏è Mapeamento de Tabelas Aplicado
"""
        
        for old_table, new_table in self.table_mapping.items():
            report_md += f"- `{old_table}` ‚Üí `{new_table}`\n"
        
        report_md += f"""
### üì¶ Corre√ß√µes de Imports
- `import sqlite3` ‚Üí `from sqlalchemy import create_engine, text`
- `sqlite3.connect()` ‚Üí `postgresql_connection()`

### üîß Corre√ß√µes SQL
- `AUTOINCREMENT` ‚Üí `SERIAL`
- `INTEGER PRIMARY KEY` ‚Üí `BIGSERIAL PRIMARY KEY`
- `DATETIME` ‚Üí `TIMESTAMP WITH TIME ZONE`
- `REAL` ‚Üí `DECIMAL`

## üíæ Backup de Seguran√ßa
- **Backup Criado:** {'‚úÖ SIM' if report_data['backup_created'] else '‚ùå N√ÉO'}
- **Localiza√ß√£o:** `backup_pre_migration/`

## üìÅ Arquivos Criados
- `src/database/postgresql_connection.py` - Configura√ß√£o PostgreSQL

## ‚ö†Ô∏è Erros Encontrados
"""
        
        if report_data['errors']:
            for error in report_data['errors']:
                report_md += f"- {error}\n"
        else:
            report_md += "‚úÖ Nenhum erro encontrado!\n"
        
        report_md += f"""
## üéØ Pr√≥ximos Passos

### ‚úÖ Se Corre√ß√µes Bem-Sucedidas:
1. **Re-executar auditoria** para confirmar corre√ß√µes
2. **Testar sistema** em ambiente de desenvolvimento
3. **Configurar PostgreSQL** na VPS
4. **Executar migra√ß√£o** com script avan√ßado

### ‚ö†Ô∏è Se Erros Encontrados:
1. **Revisar erros** listados acima
2. **Corrigir manualmente** se necess√°rio
3. **Re-executar corre√ß√£o** se poss√≠vel
4. **Validar corre√ß√µes** antes de prosseguir

## üîç Valida√ß√£o Recomendada
```bash
# Re-executar auditoria
python3 AUDITORIA_COMPATIBILIDADE_MIGRACAO.py

# Se 0 problemas cr√≠ticos:
# ‚úÖ Pronto para migra√ß√£o!
```

---
*Corre√ß√µes aplicadas em {datetime.now().strftime('%d/%m/%Y √†s %H:%M:%S')}*
"""
        
        return report_md

def main():
    """Executa corre√ß√£o autom√°tica de compatibilidade"""
    print("üîß CORRE√á√ÉO AUTOM√ÅTICA DE PROBLEMAS DE COMPATIBILIDADE")
    print("=" * 60)
    print("‚ö†Ô∏è  ATEN√á√ÉO: Este script ir√° modificar arquivos do projeto")
    print("üíæ Backup autom√°tico ser√° criado antes das modifica√ß√µes")
    print("=" * 60)
    
    # Confirmar execu√ß√£o
    confirm = input("\nüöÄ Deseja continuar com as corre√ß√µes? (s/N): ").lower().strip()
    if confirm != 's':
        print("‚ùå Corre√ß√£o cancelada pelo usu√°rio")
        return
    
    # Executar corre√ß√µes
    fixer = CompatibilityFixer()
    report_data = fixer.fix_all_compatibility_issues()
    
    # Gerar relat√≥rio detalhado
    detailed_report = fixer.generate_detailed_report(report_data)
    
    # Salvar relat√≥rio
    with open('RELATORIO_CORRECOES_APLICADAS.md', 'w', encoding='utf-8') as f:
        f.write(detailed_report)
    
    # Mostrar resumo
    print("\n" + "=" * 60)
    print("üéâ CORRE√á√ïES CONCLU√çDAS!")
    print("=" * 60)
    print(f"üìÅ Arquivos processados: {report_data['summary']['files_processed']}")
    print(f"‚úèÔ∏è  Arquivos modificados: {report_data['summary']['files_modified']}")
    print(f"üîß Total de corre√ß√µes: {report_data['summary']['total_corrections']}")
    print(f"üíæ Backup criado: {'‚úÖ SIM' if report_data['backup_created'] else '‚ùå N√ÉO'}")
    
    if report_data['errors']:
        print(f"‚ö†Ô∏è  Erros encontrados: {len(report_data['errors'])}")
        print("üìã Verifique o relat√≥rio para detalhes")
    else:
        print("‚úÖ Nenhum erro encontrado!")
    
    print(f"\nüìä RELAT√ìRIO COMPLETO: RELATORIO_CORRECOES_APLICADAS.md")
    
    # Recomenda√ß√£o
    if not report_data['errors']:
        print("\nüéØ PR√ìXIMO PASSO:")
        print("   Re-execute a auditoria para confirmar que problemas foram corrigidos:")
        print("   python3 AUDITORIA_COMPATIBILIDADE_MIGRACAO.py")
    else:
        print("\n‚ö†Ô∏è  ATEN√á√ÉO:")
        print("   Revise os erros antes de prosseguir com a migra√ß√£o")

if __name__ == "__main__":
    main()

